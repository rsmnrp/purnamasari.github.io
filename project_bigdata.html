<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Big Data Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="project_bigdata_files/libs/clipboard/clipboard.min.js"></script>
<script src="project_bigdata_files/libs/quarto-html/quarto.js"></script>
<script src="project_bigdata_files/libs/quarto-html/popper.min.js"></script>
<script src="project_bigdata_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="project_bigdata_files/libs/quarto-html/anchor.min.js"></script>
<link href="project_bigdata_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="project_bigdata_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="project_bigdata_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="project_bigdata_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="project_bigdata_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Big Data Project</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>For our big data project, my group and I analysed the used car market dynamics in Singapore by looking at the factors that affect the price of a used car and their significance.</p>
</section>
<section id="web-scraping" class="level1">
<h1>Web Scraping</h1>
<p>We collected our dataset by web-scraping from sgCarMart’s website. This is to obtain the latest information of the car market, ensuring that we maintain control over data quality and the dataset’s reliability.</p>
</section>
<section id="data-transformation-wrangling" class="level1">
<h1>Data Transformation &amp; Wrangling</h1>
<p>We proceed to data transformations and wrangling to clean our current data, making sure that most the variables in our dataset could be of use to us instead of just eliminating them.</p>
<p>First, we removed irrelevant variables such as index and CATEGORIES as they do not provide any new information that other columns were not already providing.</p>
<p>Secondly, we created new variables from existing columns. We saw that there were &gt;50 unique brands and some of them only had 1-2 observations. Thus, we created BRAND_CATEGORY from columns BRAND and MODEL_SUBMODEL, grouping these observations into categories such as Exotic, Luxury and Budget brands. This helps us in ensuring that the data is representative of the types of brand.</p>
<p>We also created variables DAYS_OF_COE_LEFT, FEATURE_COUNT, AGE_SINCE_MANUFACTURED, ACCESSORIES_COUNT, DAYS_SINCE_REGISTERED and NUM_PAST_OWNERS to utilise the existing columns better.</p>
<p>Finally, we converted our final dataframe to a parquet file, to increase the optimisation of working with big data.</p>
</section>
<section id="data-visualisation-exploratory-data-analysis" class="level1">
<h1>Data Visualisation &amp; Exploratory Data Analysis</h1>
<p>Afterwards, I carried out data visualisations &amp; exploratory data analysis. Plotting a correlation matrix between the numerical variables, I saw that variables ARF and OMV, variables ROAD_TAX, POWER and ENGINE_CAPACITY_CC have a high correlation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="FIRSTPLOT.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Correlation Matrix Between Numerical Variables</figcaption>
</figure>
</div>
<p>With this, we dropped a few variables:</p>
<ol type="1">
<li>ARF as it is derived from OMV</li>
<li>ROAD_TAX and POWER as they are functions of ENGINE_CAPACITY_CC</li>
<li>DEPRE_VAL and DEREG_VAL as they are derived from OMV</li>
<li>DESCRIPTION as we did not extract any data from it for our model</li>
<li>BRAND as we have already created BRAND_CATEGORY</li>
<li>MODEL_SUBMODEL as we have existing columns that have sufficient information</li>
</ol>
<section id="final-dataset-features" class="level2">
<h2 class="anchored" data-anchor-id="final-dataset-features">Final Dataset Features</h2>
<ol type="1">
<li>CURB_WEIGHT_KG</li>
<li>OMV</li>
<li>COE_LISTED:</li>
<li>ENGINE_CAPACITY_CC</li>
<li>DAYS_OF_COE_LEFT</li>
<li>MILEAGE_KM</li>
<li>FEATURE_COUNT</li>
<li>ACCESSORIES_COUNT</li>
<li>AGE_SINCE_MANUFACTURED</li>
<li>NO_OF_OWNERS</li>
<li>DAYS_SINCE_REGISTERED</li>
<li>TYPE</li>
<li>TRANSMISSION</li>
<li>BRAND_CATEGORY</li>
</ol>
<p>We then plot correlation plots, raster plots and bar plots with the final variables.</p>
</section>
<section id="correlation-plots-between-final-variables" class="level2">
<h2 class="anchored" data-anchor-id="correlation-plots-between-final-variables">Correlation Plots Between Final Variables</h2>
<p>We see that variables CURB_WEIGHT_KG, OMV, COE_LISTED, ENGINE_CAPACITY_CC, DAYS_OF_COE_LEFT have a positive relationship with PRICE while variables MILEAGE_KM, FEATURE_COUNT, ACCESSORIES_COUNT, AGE_SINCE_MANUFACTURED, NO_OF_OWNERS and DAYS_SINCE_REGISTERED have a negative relationship with PRICE.</p>
<p><img src="SECOND.png" class="img-fluid"></p>
</section>
<section id="raster-plots-for-numerical-variables" class="level2">
<h2 class="anchored" data-anchor-id="raster-plots-for-numerical-variables">Raster Plots for numerical variables</h2>
<p><img src="third.png" class="img-fluid"></p>
<p><img src="4.png" class="img-fluid"></p>
<p><img src="5.png" class="img-fluid"></p>
<p><img src="6.png" class="img-fluid"></p>
<p><img src="7.png" class="img-fluid"></p>
<p><img src="8.png" class="img-fluid"></p>
<p><img src="9.png" class="img-fluid"></p>
<p><img src="10.png" class="img-fluid"></p>
<p><img src="11.png" class="img-fluid"></p>
<p><img src="12.png" class="img-fluid"></p>
<p><img src="13.png" class="img-fluid"></p>
</section>
<section id="bar-plots-for-character-variables" class="level2">
<h2 class="anchored" data-anchor-id="bar-plots-for-character-variables">Bar Plots for character variables</h2>
<p><img src="14.png" class="img-fluid"></p>
<p><img src="16.png" class="img-fluid"></p>
<p><img src="444.png" class="img-fluid"></p>
</section>
</section>
<section id="modelling" class="level1">
<h1>Modelling</h1>
<p>Building a pipeline model, we initialised an empty pipeline ml_pipeline() and used functions ft_vector_assembler(), ft_standard_scaler(), ft_string_indexer() and ml_linear_regression() to combine our variables, standardising them, convert the strings value to index and combine all the variables again into a single row vector to apply linear regression.</p>
<section id="splitting-into-training-testing-set" class="level3">
<h3 class="anchored" data-anchor-id="splitting-into-training-testing-set">Splitting into training &amp; testing set</h3>
<p>We then split our dataset into a training and testing set. To make the split reproducible, we included the seed argument.</p>
<p>Using the ml_fit() function, we convert our earlier pipeline, an estimator object, to a transformer.</p>
</section>
<section id="cross-validation" class="level3">
<h3 class="anchored" data-anchor-id="cross-validation">Cross-Validation</h3>
<p>We tried out different model specifications by defining a cross-validator, by setting elastic_net_param to a vector of values 0 and 1 to evaluate the Ridge and Lasso models with lambda values 0.1, 0.005 and 0.001 and setting number of folds to 10 to carry out a 10-fold cross validation.</p>
<p>We utilised ml_fit() once again to fit our model with df_train and ml_predict() to select the best model. Our best model is</p>
<p>PRICE = 13975.081<strong>(MILEAGE_KM)</strong> + 2263.033<strong>(CURB_WEIGHT_KG)</strong> + 185926.974<strong>(OMV)</strong> + 728.829<strong>(COE_LISTED)</strong> - 16574.058<strong>(ENGINE_CAPACITY_CC)</strong> -99.682<strong>(AGE_SINCE_MANUFACTURED)</strong> - 52920.730<strong>(DAYS_SINCE_REGISTERED)</strong> -9742.942<strong>(NUM_PAST_OWNERS)</strong> + 26257.671<strong>(DAYS_OF_COE_LEFT)</strong> -2353.743<strong>(FEATURE_COUNT)</strong> - 1024.575<strong>(ACCESSORIES_COUNT)</strong> + 2940.832<strong>(TYPE_index)</strong> + 92549.120<strong>(TRANSMISSION_index)</strong> - 5267.821<strong>(BRAND_CATEGORY_index)</strong> with an RSME of 78359.33 and an R^2 of 0.789.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>I have detailed how our model can present potential car owners with tools and visualisations to make well-informed choices should they want to purchase a resale car. Users will better understand how resale car prices vary with respect to the different predictors. To ensure our model is publicly available for those who need it, we have published the repository at <a href="https://github.com/kowsiii/bigdata-resalecaresinSG">this link</a>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>